# 三个服务之间的关系

traffic\_cop traffic\_manager traffic\_server 工作关系

Traffic Server包括三个一起工作的进程来服务Traffic Server的请求，管理/控制/监控系统的健康状况。图1说明了三个进程的关系，三个进程将会在下面描述。
![](/assets/进程之间的关系.jpg)
1）traffic_server进程是 Traffic Server的事务处理引擎。它负责接收连接、处理协议请求以及从本地缓存或源服务器提供资源。

2）traffic_manager进程是用来命令和控制Traffic Server的工具，负责启动、监控以及重新配置traffic_server进程。traffic_manager进程同时负责代理自动配置端口、统计接口、集群管理以及vip故障转移。

如果traffic_manager进程检测到traffic_server进程失败，它不仅会立即重启该进程，而且会为所有传入的请求维护一个连接队列。在traffic_server重启前的几秒内传入的所有连接将会被保存在连接队列中，并以FIFO的方式处理。这个连接队列接受任何server故障重启时的连接。
 

3）traffic_cop进程监控traffic_server和traffic_manager进程的健康状况。traffic_cop进程通过抓取合成web页面的心跳请求方式周期性的（每分钟若干次）查询traffic_server和traffic_manager进程。如果失败事件发生（如果在超时时间间隔内没有收到请求或者收到错误的请求），traffic_cop重启traffic_server和traffic_manager进程。系统这样设计的好处便是给traffic_server进程加上了来自traffic_manager和traffic_cop的双重保障，因为traffic_server进程是工作进程，必须保证它的正常运行。-

4）traffic server采用的是多线程异步事件处理模型：Traffic Server并不是为每个连接都建立一个线程，而是事先创建一组数量可配置的工作线程，每一个工作线程上都运行着独立的异步事件处理程序。traffic_server创建若干组Thread，并将Event按类型调度到相应的Thread的Event队列上，Thread通过执行Event对应的Continuation中的回调函数，来完成状态的迁移。从初始态到终止态的迁移代表了整个事件的执行过程，而Thread是永不退出的，等待着下一个事件的到来。

```shell
[root@XNOP061-CMC-CT-JSCZ-P-164-89 wanrui]# cat /usr/local/squid/etc/trafficserver/records.config|grep 9001
CONFIG proxy.config.admin.autoconf_port INT 9001
[root@XNOP061-CMC-CT-JSCZ-P-164-89 wanrui]# cat /usr/local/squid/etc/trafficserver/records.config|grep 9002
CONFIG proxy.config.process_manager.mgmt_port INT 9002
```

```
[root@XNOP061-CMC-CT-JSCZ-P-164-89 wanrui]# ss -lp |grep 900
LISTEN     0      5                       *:9001                     *:*        users:(("traffic_manager",78538,13))
LISTEN     0      1024            127.0.0.1:9002                     *:*        users:(("[ET_NET 0]",78670,740))
```

```
[root@XNOP061-CMC-CT-JSCZ-P-164-89 wanrui]# ps -ef|grep traf
root       9618      1  0 Aug06 ?        00:00:24 /usr/local/squid//bin/traffic_cop
root      78538   9618  0 Aug12 ?        00:04:40 /usr/local/squid/bin/traffic_manager
root      78670  78538 74 Aug12 ?        4-00:15:26 /usr/local/squid/bin/traffic_server -M --httpport 51899:fd=9
```

## traffic server 内部保活机制

以下分析基于ats 6.1.1版本代码（wanrui@qq.com）
流程 如下图，TrafficCop探测traffic_server超过两次失败将直接重启服务；

```
graph LR
TrafficCop-->traffic_server:8084
traffic_server:8084-->trafficmanager:8083
```

service |  state  |  status  |  action
--------|---------|----------|---------------
manager |   up    |    ok    |  nothing
server  |   up    |    ok    |
manager |   up    |    bad   |  kill manager
server  |   up    |    ?     |
manager |   up    |    ok    |  kill manager
server  |   down  |    ?     |
manager |   up    |    ok    |  kill server
server  |   up    |    bad   |


- traffic cop 探测traffic server 的探测报文中使用的端口，"GET http://127.0.0.1:%d/synthetic.txt HTTP/1.0\r\n\r\n", synthetic_port);
```
static int synthetic_port = 8083;
```
- traffic cop 检查 traffic manager 服务是否正常的端口，默认端口为 8088；外部可以通过配置项进行配置 proxy.config.cluster.rsport
```
static int rs_port = 8088;
```
- traffic cop 探测traffic_server 服务是否正常使用端口，默认端口为8084； 外部可配置使用配置项 proxy.config.process_manager.mgmt_port
```
static int http_backdoor_port = 8084;
```
- traffic cop 探测traffic server 探测超时时间为3min
```
static const int server_timeout = 3 * 60; 
```
- traffic cop 探测traffic server的探测间隔10s
```
static const int sleep_time = 10;      
```

```
//对应的读取逻辑配置 
config_read_int("proxy.config.process_manager.mgmt_port", &http_backdoor_port, true);
config_read_int("proxy.config.admin.synthetic_port", &synthetic_port, true);
config_read_int("proxy.config.cluster.rsport", &rs_port, true);
config_read_int("proxy.config.admin.autoconf_port", &autoconf_port, true);



```


Cop检查逻辑
![](/assets/Cop检查逻辑.png) 
Cop杀死逻辑
![](/assets/Cop杀死逻辑.png) 
Server代理逻辑
![](/assets/Server代理逻辑.png) 
Manager服务逻辑
![](/assets/Manager服务逻辑.png) 



