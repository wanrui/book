## ATS 如何hook到对应的事件？

ATS 可以使用如下方法进行对应事件的监听：

```cc
tsapi void TSLifecycleHookAdd(TSLifecycleHookID id, TSCont contp);
tsapi void TSHttpHookAdd(TSHttpHookID id, TSCont contp);
tsapi void TSHttpSsnHookAdd(TSHttpSsn ssnp, TSHttpHookID id, TSCont contp);
tsapi void TSHttpTxnHookAdd(TSHttpTxn txnp, TSHttpHookID id, TSCont contp);
tsapi const char *TSHttpHookNameLookup(TSHttpHookID hook);
```

上面已经介绍ATS如何通过配置文件，加载起来对应的插件了。在加载的过程中，势必会调用 TSPluginInit 函数。这个函数  
插件使用TSHttpHookAdd 函数进行具体事件的挂载。标准的使用方法如下：

```cc
TSHttpHookAdd(TS_HTTP_READ_REQUEST_HDR_HOOK, TSContCreate(stats_origin, NULL));
```

通过TSContCreate 创建一个Continuation ，然后传入http\_global\_hooks对象中保存

```cc
void
TSHttpHookAdd(TSHttpHookID id, TSCont contp)
{
  INKContInternal *icontp;
  sdk_assert(sdk_sanity_check_continuation(contp) == TS_SUCCESS);
  sdk_assert(sdk_sanity_check_hook_id(id) == TS_SUCCESS);

  icontp = reinterpret_cast<INKContInternal *>(contp);

  if (id >= TS_SSL_FIRST_HOOK && id <= TS_SSL_LAST_HOOK) {
    TSSslHookInternalID internalId = static_cast<TSSslHookInternalID>(id - TS_SSL_FIRST_HOOK);
    ssl_hooks->append(internalId, icontp);
  } else { // Follow through the regular HTTP hook framework
    http_global_hooks->append(id, icontp);
  }
}
/* HTTP transactions */
void
TSHttpTxnHookAdd(TSHttpTxn txnp, TSHttpHookID id, TSCont contp)
{
  sdk_assert(sdk_sanity_check_txn(txnp) == TS_SUCCESS);
  sdk_assert(sdk_sanity_check_continuation(contp) == TS_SUCCESS);
  sdk_assert(sdk_sanity_check_hook_id(id) == TS_SUCCESS);

  HttpSM *sm = (HttpSM *)txnp;
  sm->txn_hook_append(id, (INKContInternal *)contp);
}

/* HTTP sessions */
void
TSHttpSsnHookAdd(TSHttpSsn ssnp, TSHttpHookID id, TSCont contp)
{
  sdk_assert(sdk_sanity_check_http_ssn(ssnp) == TS_SUCCESS);
  sdk_assert(sdk_sanity_check_continuation(contp) == TS_SUCCESS);
  sdk_assert(sdk_sanity_check_hook_id(id) == TS_SUCCESS);

  HttpClientSession *cs = (HttpClientSession *)ssnp;
  cs->ssn_hook_append(id, (INKContInternal *)contp);
}
```

http\_global\_hooks 定义类型为HttpAPIHooks，这个类的继承关系如下:  
![](cpp_api_image/UMLClassDiagram-HttpAPIHooks.png)

```cpp
class APIHooks
{
public:
  void prepend(INKContInternal *cont);
  void append(INKContInternal *cont);
  APIHook *get() const;
  void clear();
  bool is_empty() const;
  void invoke(int event, void *data);

private:
  Que(APIHook, m_link) m_hooks;
};

inline void
APIHooks::invoke(int event, void *data)
{
  for (APIHook *hook = m_hooks.head; NULL != hook; hook = hook->next())
    hook->invoke(event, data);
}
```

```cpp
#0  stats_origin (contp=0x1150fa0, event=TS_EVENT_HTTP_READ_REQUEST_HDR, edata=0x7fffede27080) at stats_over_http.c:260
#1  0x0000000000599aa5 in HttpSM::state_api_callout (this=0x7fffede27080, event=<value optimized out>, data=<value optimized out>)
    at HttpSM.cc:1382
#2  0x000000000059f410 in HttpSM::set_next_state (this=0x7fffede27080) at HttpSM.cc:6955
#3  0x00000000005963bc in HttpSM::state_read_client_request_header (this=0x7fffede27080, event=<value optimized out>, 
    data=<value optimized out>) at HttpSM.cc:771
#4  0x000000000059b1b8 in HttpSM::main_handler (this=0x7fffede27080, event=100, data=0x7fffe0017e38) at HttpSM.cc:2561
#5  0x00000000005987d2 in handleEvent (this=0x7fffede27080) at ../../iocore/eventsystem/I_Continuation.h:153
#6  setup_client_read_request_header (this=0x7fffede27080) at HttpSM.cc:565
#7  HttpSM::handle_api_return (this=0x7fffede27080) at HttpSM.cc:1507
#8  0x0000000000599c93 in HttpSM::state_api_callout (this=0x7fffede27080, event=<value optimized out>, data=0x0) at HttpSM.cc:1464
#9  0x00000000005a07d8 in do_api_callout_internal (this=0x7fffede27080, client_vc=<value optimized out>, 
    buffer_reader=<value optimized out>) at HttpSM.cc:4914
#10 do_api_callout (this=0x7fffede27080, client_vc=<value optimized out>, buffer_reader=<value optimized out>) at HttpSM.cc:391
#11 state_add_to_list (this=0x7fffede27080, client_vc=<value optimized out>, buffer_reader=<value optimized out>) at HttpSM.cc:418
#12 HttpSM::attach_client_session (this=0x7fffede27080, client_vc=<value optimized out>, buffer_reader=<value optimized out>)
    at HttpSM.cc:544
#13 0x000000000057953c in HttpClientSession::new_transaction (this=0x7fffe801cd40) at HttpClientSession.cc:141
#14 0x00000000004e8449 in state_api_callout (this=0x7fffe801cd40, id=<value optimized out>) at ProxyClientSession.cc:119
#15 ProxyClientSession::do_api_callout (this=0x7fffe801cd40, id=<value optimized out>) at ProxyClientSession.cc:145
#16 0x000000000057b274 in HttpClientSession::new_connection (this=0x7fffe801cd40, new_vc=<value optimized out>, 
    iobuf=<value optimized out>, reader=<value optimized out>, backdoor=false) at HttpClientSession.cc:220
#17 0x0000000000575469 in HttpSessionAccept::accept (this=0x1276580, netvc=0x7fffe0017d20, iobuf=0x1275da0, reader=0x1275db8)
    at HttpSessionAccept.cc:74
#18 0x00000000004e7d03 in ProtocolProbeTrampoline::ioCompletionEvent (this=0x7fffe8000970, event=<value optimized out>, 
    edata=<value optimized out>) at ProtocolProbeSessionAccept.cc:123
#19 0x0000000000724ef9 in handleEvent (event=<value optimized out>, vc=0x7fffe0017d20)
    at ../../iocore/eventsystem/I_Continuation.h:153
#20 read_signal_and_update (event=<value optimized out>, vc=0x7fffe0017d20) at UnixNetVConnection.cc:150
#21 0x0000000000729bde in read_from_net (nh=0x7ffff6721b90, vc=0x7fffe0017d20, thread=0x7ffff671e010) at UnixNetVConnection.cc:390
#22 0x000000000071b4c0 in NetHandler::mainNetEvent (this=0x7ffff6721b90, event=<value optimized out>, e=<value optimized out>)
    at UnixNet.cc:518
#23 0x00000000007489a5 in handleEvent (this=0x7ffff671e010, e=0x1094d00, calling_code=5) at I_Continuation.h:153
#24 EThread::process_event (this=0x7ffff671e010, e=0x1094d00, calling_code=5) at UnixEThread.cc:128
#25 0x00000000007492e9 in EThread::execute (this=0x7ffff671e010) at UnixEThread.cc:252
#26 0x0000000000747e1a in spawn_thread_internal (a=0x1067450) at Thread.cc:86
#27 0x00000039040079d1 in start_thread () from /lib64/libpthread.so.0
#28 0x0000003903ce8b5d in clone () from /lib64/libc.so.6
```

```cpp
    This set of enums represents the possible hooks where you can
    set up continuation callbacks. The functions used to register a
    continuation for a particular hook are:

    TSHttpHookAdd: adds a global hook. You can globally add
    any hook except for
     - TS_HTTP_REQUEST_TRANSFORM_HOOK
     - TS_HTTP_RESPONSE_TRANSFORM_HOOK
     - TS_HTTP_RESPONSE_CLIENT_HOOK

    The following hooks can ONLY be added globally:
     - TS_HTTP_SELECT_ALT_HOOK
     - TS_HTTP_SSN_START_HOOK
     - TS_HTTP_SSN_CLOSE_HOOK

    TSHttpSsnHookAdd: adds a transaction hook to each transaction
    within a session. You can only use transaction hooks with this call:
     - TS_HTTP_READ_REQUEST_HDR_HOOK
     - TS_HTTP_OS_DNS_HOOK
     - TS_HTTP_SEND_REQUEST_HDR_HOOK
     - TS_HTTP_READ_CACHE_HDR_HOOK
     - TS_HTTP_READ_RESPONSE_HDR_HOOK
     - TS_HTTP_SEND_RESPONSE_HDR_HOOK
     - TS_HTTP_REQUEST_TRANSFORM_HOOK
     - TS_HTTP_RESPONSE_TRANSFORM_HOOK
     - TS_HTTP_RESPONSE_CLIENT_HOOK
     - TS_HTTP_TXN_START_HOOK
     - TS_HTTP_TXN_CLOSE_HOOK

    TSHttpTxnHookAdd: adds a callback at a specific point within
    an HTTP transaction. The following hooks can be used with this
    function:
     - TS_HTTP_READ_REQUEST_HDR_HOOK
     - TS_HTTP_OS_DNS_HOOK
     - TS_HTTP_SEND_REQUEST_HDR_HOOK
     - TS_HTTP_READ_CACHE_HDR_HOOK
     - TS_HTTP_READ_RESPONSE_HDR_HOOK
     - TS_HTTP_SEND_RESPONSE_HDR_HOOK
     - TS_HTTP_REQUEST_TRANSFORM_HOOK
     - TS_HTTP_RESPONSE_TRANSFORM_HOOK
     - TS_HTTP_TXN_CLOSE_HOOK

    The two transform hooks can ONLY be added as transaction hooks.

    TS_VCONN_PRE_ACCEPT_HOOK - Called before the SSL hand
    shake starts.  No handshake data has been read or sent (from the
    proxy) at this point

    TS_HTTP_LAST_HOOK _must_ be the last element. Only right place
    to insert a new element is just before TS_HTTP_LAST_HOOK.
```



