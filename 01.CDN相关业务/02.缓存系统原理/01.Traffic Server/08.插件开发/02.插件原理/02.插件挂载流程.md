##  ATS 如何知道插件的存在？ 
ATS 有一个配置插件的配置文件，通过读取配置文件里面的条目，然后使用dlsym方法把插件so文件中的 TSPluginInit 函数指针找出来，形成一个数据结构，保存在PluginRegInfo类型的 plugin_reg_list对象中（对象含有动态库的文件句柄）。 
path = RecConfigReadConfigPath(NULL, "plugin.config");
TSPluginInit 调用过程
![](cpp_api_image/CalledBy-plugin_load.png) 
```cpp
#0  TSPluginInit (argc=1, argv=0x7fffffffe060) at stats_over_http.c:326
#1  0x00000000004e110a in plugin_load (validateOnly=false) at Plugin.cc:126
#2  plugin_init (validateOnly=false) at Plugin.cc:283
#3  0x00000000004d7e4f in main (argv=<value optimized out>) at Main.cc:1796
```

```cpp
init = (init_func_t)dlsym(plugin_reg_current->dlh, "TSPluginInit");
if (!init) {
    delete plugin_reg_current;
    if (validateOnly) {
        return false;
    }
    Fatal("unable to find TSPluginInit function in '%s': %s", path, dlerror());
    return false; // this line won't get called since Fatal brings down ATS
}
init(argc, argv);// 调用TSPluginInit
```
关于 dlsym 函数的使用：
假设在my.so中定义了一个void mytest()函数，那在使用my.so时先声明一个函数指针：
```cpp
void(*pMytest)();
```
接下来先将那个my.so载入：
```cpp
pHandle=dlopen("my.so",RTLD_LAZY);//详见dlopen函数
```
然后使用dlsym函数将函数指针 pMytest 指向 mytest() 函数：
```cpp
pMytest=(void(*)())dlsym(pHandle,"mytest");//可见放在双引号中的mytest不用加括号,即使有参数也不用
```
（可调用dlerror();返回错误信息，正确返回为空）
最后通过调用函数指针执行mytest函数：
```cpp
int main(){
    //......
    pMytest();
    //......
    return0;
}
```

TSRemapNewInstance 调用过程
![](cpp_api_image/CalledBy-remap_load_plugin.png) 
```cpp
(gdb) bt
#0  TSRemapNewInstance (argc=2, argv=0x7ffffffe7560, instance_handle=0x7ffffffece28, errbuf=0x7ffffffec560 "", errbuf_size=2047)
    at RemapPlugin.cc:90
#1  0x00000000005f966f in remap_load_plugin (argv=0x7fffffff2040, argc=<value optimized out>, mp=<value optimized out>, 
    errbuf=0x7ffffffed720 "", errbufsize=1024, jump_to_argc=<value optimized out>, plugin_found_at=0x7ffffffedfd0)
    at RemapConfig.cc:862
#2  0x00000000005fcaf3 in remap_parse_config_bti (path=0x1268dd0 "/home/wanrui/ts_install_6.1.1/etc/trafficserver/remap.config", 
    bti=0x7ffffffee030) at RemapConfig.cc:1317
#3  0x00000000005fd9e2 in remap_parse_config (path=0x1268dd0 "/home/wanrui/ts_install_6.1.1/etc/trafficserver/remap.config", 
    rewrite=0x12741a0) at RemapConfig.cc:1367
#4  0x00000000005f5d2a in UrlRewrite::BuildTable (this=0x12741a0, 
    path=0x1268dd0 "/home/wanrui/ts_install_6.1.1/etc/trafficserver/remap.config") at UrlRewrite.cc:686
#5  0x00000000005f879d in UrlRewrite::UrlRewrite (this=0x12741a0) at UrlRewrite.cc:92
#6  0x00000000004e8b6c in init_reverse_proxy () at ReverseProxy.cc:75
#7  0x000000000058348a in init_HttpProxyServer (n_accept_threads=1) at HttpProxyServerMain.cc:242
#8  0x00000000004d802d in main (argv=<value optimized out>) at Main.cc:1846
```
remap 插件对应函数从so 文件中加载：
```cpp
remap_load_plugin--
      pi->fp_tsremap_init = (remap_plugin_info::_tsremap_init *)dlsym(pi->dlh, TSREMAP_FUNCNAME_INIT);
      pi->fp_tsremap_done = (remap_plugin_info::_tsremap_done *)dlsym(pi->dlh, TSREMAP_FUNCNAME_DONE);
      pi->fp_tsremap_new_instance = (remap_plugin_info::_tsremap_new_instance *)dlsym(pi->dlh, TSREMAP_FUNCNAME_NEW_INSTANCE);
      pi->fp_tsremap_delete_instance =
        (remap_plugin_info::_tsremap_delete_instance *)dlsym(pi->dlh, TSREMAP_FUNCNAME_DELETE_INSTANCE);
      pi->fp_tsremap_do_remap = (remap_plugin_info::_tsremap_do_remap *)dlsym(pi->dlh, TSREMAP_FUNCNAME_DO_REMAP);
      pi->fp_tsremap_os_response = (remap_plugin_info::_tsremap_os_response *)dlsym(pi->dlh, TSREMAP_FUNCNAME_OS_RESPONSE);
```
remap_plugin_info 插件类的内容如下，需要实现的函数如下

```cpp
#define TSREMAP_FUNCNAME_INIT "TSRemapInit"
#define TSREMAP_FUNCNAME_DONE "TSRemapDone"
#define TSREMAP_FUNCNAME_NEW_INSTANCE "TSRemapNewInstance"
#define TSREMAP_FUNCNAME_DELETE_INSTANCE "TSRemapDeleteInstance"
#define TSREMAP_FUNCNAME_DO_REMAP "TSRemapDoRemap"
#define TSREMAP_FUNCNAME_OS_RESPONSE "TSRemapOSResponse"
```

 1. _tsremap_init：TSRemapInit
 2. _tsremap_done:TSRemapDone
 3.  _tsremap_new_instance:TSRemapNewInstance
 4.   _tsremap_delete_instance；TSRemapDeleteInstance
 5.   _tsremap_do_remap：TSRemapDoRemap
 6.   _tsremap_os_responseTSRemapOSResponse

```cpp
class remap_plugin_info
{
public:
  typedef TSReturnCode _tsremap_init(TSRemapInterface *api_info, char *errbuf, int errbuf_size);
  typedef void _tsremap_done(void);
  typedef TSReturnCode _tsremap_new_instance(int argc, char *argv[], void **ih, char *errbuf, int errbuf_size);
  typedef void _tsremap_delete_instance(void *);
  typedef TSRemapStatus _tsremap_do_remap(void *ih, TSHttpTxn rh, TSRemapRequestInfo *rri);
  typedef void _tsremap_os_response(void *ih, TSHttpTxn rh, int os_response_type);

  remap_plugin_info *next;
  char *path;
  int path_size;
  void *dlh; /* "handle" for the dynamic library */
  _tsremap_init *fp_tsremap_init;
  _tsremap_done *fp_tsremap_done;
  _tsremap_new_instance *fp_tsremap_new_instance;
  _tsremap_delete_instance *fp_tsremap_delete_instance;
  _tsremap_do_remap *fp_tsremap_do_remap;
  _tsremap_os_response *fp_tsremap_os_response;

  remap_plugin_info(char *_path);
  ~remap_plugin_info();

  remap_plugin_info *find_by_path(char *_path);
  void add_to_list(remap_plugin_info *pi);
  void delete_my_list();
};
```
